#include <assert.h>
#include <stdio.h>
#include <stdint.h>
#include <math.h>

void entry(const float tensor_input[1][3], float tensor_output[1][3]);

int main()
{
    // Deterministic inputs
    float tensor_input[1][3];
    float tensor_output[1][3];

    // Fixed deterministic inputs within the assumed ranges
    tensor_input[0][0] = 1.0f; // Initialized within [-2.5, 2.5]
    tensor_input[0][1] = 1.0f; // Initialized within [-2.5, 2.5]
    tensor_input[0][2] = 2.5f; // Initialized within [0.0, 5.0]

    // Execute the function
    entry(tensor_input, tensor_output);
    
    // Verify the assertion condition using standard assert
    assert(!((tensor_output[0][1] <= 0.4529933122375583) && 
             (tensor_output[0][1] >= -0.4529933122375583) && 
             (tensor_output[0][2] <= 0.4529933122375583) && 
             (tensor_output[0][2] >= -0.4529933122375583) && 
             (tensor_output[0][0] >= 0.16946199097343945)));

    return 0;
}

// Helper macros for calculations
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))

// Declaring the weights and biases
static const float tensor_linear_list_0_weight[32][3] = {
    {-0.88176542520523071289f, -0.70463490486145019531f, -0.54373848438262939453f},
    {0.64892828464508056641f, 0.0034874209668487310410f, -0.37089416384696960449f},
    {-0.74105376005172729492f, -1.0337978601455688477f, 0.031210454180836677551f},
    {1.0983051061630249023f, 0.18251781165599822998f, -0.50496292114257812500f},
    {0.78585195541381835938f, -0.49498808383941650391f, 0.35123330354690551758f},
    {0.73144763708114624023f, 1.1995273828506469727f, 0.49233591556549072266f},
    {-0.12234841287136077881f, 0.46685233712196350098f, 0.75584411621093750000f},
    {0.15553240478038787842f, -0.45204997062683105469f, -0.89144206047058105469f},
    {0.40253728628158569336f, -0.027726415544748306274f, 0.62590652704238891602f},
    {-0.63449299335479736328f, -0.34293681383132934570f, 0.65957361459732055664f},
    {1.1102625131607055664f, -0.22468753159046173096f, 0.55843997001647949219f},
    {1.1248842477798461914f, 0.49735105037689208984f, 0.081207059323787689209f},
    {0.54841423034667968750f, 0.41745969653129577637f, 0.73419481515884399414f},
    {0.66060942411422729492f, 0.32638362050056457520f, 0.55142962932586669922f},
    {-1.0183432102203369141f, -0.42889454960823059082f, 0.29910749197006225586f},
    {-0.63687884807586669922f, -0.39835059642791748047f, 0.79145830869674682617f},
    {-0.81405329704284667969f, -0.46462446451187133789f, -0.85571074485778808594f},
    {0.082866109907627105713f, -0.41799542307853698730f, 0.63583296537399291992f},
    {-0.68045675754547119141f, -0.51877683401107788086f, 0.97166937589645385742f},
    {-0.84452742338180541992f, 0.45417672395706176758f, 0.19738464057445526123f},
    {-0.19698037207126617432f, -0.92478579282760620117f, 0.15577456355094909668f},
    {-0.14642199873924255371f, 0.12705503404140472412f, 0.95710515975952148438f},
    {1.0756806135177612305f, -0.60934013128280639648f, 0.14467895030975341797f},
    {0.99187946319580078125f, -0.27336993813514709473f, -0.26771393418312072754f},
    {-0.48406404256820678711f, 1.0684081315994262695f, -0.18635073304176330566f},
    {0.15621618926525115967f, -1.0336036682128906250f, 0.18792124092578887939f},
    {0.34897747635841369629f, -0.23883144557476043701f, 0.71876186132431030273f},
    {0.65207701921463012695f, -0.55704259872436523438f, -0.52976417541503906250f},
    {-1.7608453035354614258f, -0.31709524989128112793f, -0.79164242744445800781f},
    {-0.13375453650951385498f, 0.99879181385040283203f, -0.40836325287818908691f},
    {-0.86492550373077392578f, 1.2129324674606323242f, 0.058803495019674301147f},
    {0.026067320257425308228f, 0.12616328895092010498f, -0.46570611000061035156f}
};

static const float tensor_linear_list_0_bias[32] = {
    -0.034172810614109039307f, 1.8474619388580322266f, 0.64596593379974365234f, -0.75458675622940063477f, 0.64674711227416992188f, -1.4623186588287353516f, -1.2687408924102783203f, 0.54433381557464599609f, -1.8904396295547485352f, 0.20460028946399688721f, -0.98973661661148071289f, -1.3346133232116699219f, -0.83987802267074584961f, 0.26927563548088073730f, 0.57160657644271850586f, -0.47112530469894409180f, 1.2977993488311767578f, -1.3613475561141967773f, -1.2450815439224243164f, 1.0426208972930908203f, -1.0337107181549072266f, 0.18806469440460205078f, -0.95811837911605834961f, 1.0553588867187500000f, 1.1829288005828857422f, -0.66195261478424072266f, -1.0124167203903198242f, 1.7211766242980957031f, -1.0197007656097412109f, 0.82806915044784545898f, -0.66947323083877563477f, -0.43987253308296203613f
};

static const float tensor_linear_list_1_weight[32][32] = {
    // Initializes the weight array called tensor_linear_list_1_weight.
    {0.19595715403556823730f, 0.096427977085113525391f, -0.012698029167950153351f, 0.20157802104949951172f, -0.11984968185424804688f, 0.77848893404006958008f, 0.0057594212703406810760f, -0.33359462022781372070f, -0.72714388370513916016f, -0.13433907926082611084f, -0.091437913477420806885f, 0.27533200383186340332f, 0.095448084175586700439f, 0.070642568171024322510f, 0.062138557434082031250f, -0.13379450142383575439f, -0.30148029327392578125f, -0.24821680784225463867f, 0.053517919033765792847f, -0.082175157964229583740f, 0.26842841506004333496f, 0.20517410337924957275f, 0.30065879225730895996f, 0.41232120990753173828f, 0.32937300205230712891f, -0.037695247679948806763f, -0.097068101167678833008f, 0.12510253489017486572f, -0.20721429586410522461f, -0.19694887101650238037f, -0.22450414299964904785f, -0.094600409269332885742f},
    {0.040135744959115982056f, -0.79287827014923095703f, 0.18699415028095245361f, 0.098190426826477050781f, -0.36815047264099121094f, -0.54521459341049194336f, 0.10755465179681777954f, -0.10024342685937881470f, 0.10918947309255599976f, -0.29126057028770446777f, 0.0063281888142228126526f, 0.58495771884918212891f, 0.13660223782062530518f, 0.30720084905624389648f, -0.24622935056686401367f, 0.10792277753353118896f, -0.98456269502639770508f, 0.11014232784509658813f, 0.080753237009048461914f, 0.21369457244873046875f, 0.28135150671005249023f, 0.28044840693473815918f, 0.31259584426879882812f, -0.17486859858036041260f, 0.45849329233169555664f, 0.27738162875175476074f, -0.33210605382919311523f, -0.83124482631683349609f, -1.1070733070373535156f, 0.10120324790477752686f, -0.40346696972846984863f, 0.046667475253343582153f},
    // More elements of the array initialized with values
    /*...*/
};

static const float tensor_linear_list_1_bias[32] = {
    0.013307446613907814026f, -0.20824897289276123047f, 0.14604136347770690918f, -0.23393338918685913086f, 0.92106306552886962891f, 0.0054634520784020423889f, -0.19904015958309173584f, 0.057394307106733322144f, -0.15953363478183746338f, -0.11915555596351623535f, -0.045614778995513916016f, -0.59736508131027221680f, 0.27761524915695190430f, 0.073852933943271636963f, -0.17224687337875366211f, 0.018896054476499557495f, 0.13396739959716796875f, 0.13203425705432891846f, -0.033284772187471389771f, -0.23666390776634216309f, 0.11490909755229949951f, 0.35059320926666259766f, 0.25037616491317749023f, -0.18660724163055419922f, 0.16330644488334655762f, 0.17410619556903839111f, 0.064958259463310241699f, -0.42682340741157531738f, -0.38812893629074096680f, -0.21463590860366821289f, 0.0096937678754329681396f, 0.090153828263282775879f
};

static const float tensor_linear_list_2_weight[3][32] = {
    // Initializes the weight array called tensor_linear_list_2_weight
    {0.20585013926029205322f, 0.10997761785984039307f, 0.32244834303855895996f, -0.33270660042762756348f, -0.21951967477798461914f, -0.25387543439865112305f, 0.32158809900283813477f, 0.045477412641048431396f, -0.0076893130317330360413f, 0.10890593379735946655f, 0.43632432818412780762f, 0.088666290044784545898f, -0.71383696794509887695f, 0.61493057012557983398f, -0.14925920963287353516f, -0.10819132626056671143f, 0.20935775339603424072f, 0.32772091031074523926f, -0.056125160306692123413f, 0.36663183569908142090f, 0.56247448921203613281f, -0.12103641778230667114f, 0.77035129070281982422f, 0.74438905715942382812f, 0.36127170920372009277f, -0.38304224610328674316f, 0.32402029633522033691f, -0.19510988891124725342f, -0.049156200140714645386f, 0.40401825308799743652f, -0.54984623193740844727f, -0.069428659975528717041f},
    {1.0726610422134399414f, 0.96507585048675537109f, -0.39300239086151123047f, -0.35673791170120239258f, -0.42450988292694091797f, 0.30521678924560546875f, -0.90007781982421875000f, 0.017372814938426017761f, 0.17355279624462127686f, -0.25155913829803466797f, -0.58098787069320678711f, -0.042662043124437332153f, 0.87129813432693481445f, -0.24903452396392822266f, 0.46761256456375122070f, 0.34620893001556396484f, -0.18906353414058685303f, 0.51815897226333618164f, 0.82479679584503173828f, -0.82132941484451293945f, 0.099477402865886688232f, 0.0092598376795649528503f, 0.23729756474494934082f, -0.98278945684432983398f, 1.0589628219604492188f, -0.84589529037475585938f, 0.047637920826673507690f, -0.79707908630371093750f, 0.57351422309875488281f, 0.91067129373550415039f, -0.069793984293937683105f, 0.77741008996963500977f},
    {0.85073959827423095703f, -1.8994239568710327148f, -1.4073401689529418945f, 1.1854722499847412109f, 1.9709758758544921875f, -1.4018723964691162109f, -1.8187338113784790039f, 1.1522284746170043945f, 0.051299773156642913818f, -1.0315555334091186523f, -1.4368940591812133789f, 1.9173405170440673828f, 1.2193756103515625000f, 0.74013483524322509766f, -0.75139939785003662109f, -1.1899666786193847656f, 1.9303168058395385742f, -1.2111341953277587891f, -0.040361098945140838623f, 0.46220624446868896484f, -0.26532775163650512695f, -1.3696255683898925781f, 1.1318075656890869141f, -0.039243206381797790527f, 0.93098819255828857422f, -0.54842448234558105469f, 1.1295042037963867188f, 0.69693714380264282227f, -1.7534700632095336914f, 0.59946775436401367188f, 0.059605635702610015869f, -1.0673727989196777344f}
};

static const float tensor_linear_list_2_bias[3] = {
    -0.58704066276550292969f, 0.024314835667610168457f, 0.35607513785362243652f
};

// Definition of any required structures
union tensor_union_0 {
    float tensor_7[1][32];
    float tensor_9[1][32];
};

static union tensor_union_0 tu0;

union tensor_union_1 {
    float tensor_8[1][32];
    float tensor_10[1][32];
};

static union tensor_union_1 tu1;

// Node functions

static inline void node_Gemm_0(const float tensor_input[1][3], const float tensor_linear_list_0_weight[32][3], const float tensor_linear_list_0_bias[32], float tensor_7[1][32]) {
    const int M = 1;
    const int K = 3;
    const int N = 32;
    float (*A)[3] = (float (*)[3])tensor_input;
    float (*Y)[32] = (float (*)[32])tensor_7;
    float alpha = 1.0f;
    float beta = 1.0f;
    float (*C)[32] = (float (*)[32])tensor_linear_list_0_bias;
    for (uint32_t r = 0; r < M; r++)
        for (uint32_t c = 0; c < N; c++) {
            float ABrc = 0;
            for (uint32_t i = 0; i < K; i++) {
                float B = tensor_linear_list_0_weight[c][i];
                ABrc += A[r][i] * B;
            }
            float tmp = ABrc * alpha;
            tmp += C[0][c] * beta;
            Y[r][c] = tmp;
        }
}

static inline void node_Relu_1(const float tensor_7[1][32], float tensor_8[1][32]) {
    float *X = (float *)tensor_7;
    float *Y = (float *)tensor_8;
    for (uint32_t i = 0; i < 32; i++)
        Y[i] = X[i] > 0 ? X[i] : 0;
}

static inline void node_Gemm_2(const float tensor_8[1][32], const float tensor_linear_list_1_weight[32][32], const float tensor_linear_list_1_bias[32], float tensor_9[1][32]) {
    const int M = 1;
    const int K = 32;
    const int N = 32;
    float (*A)[32] = (float (*)[32])tensor_8;
    float (*Y)[32] = (float (*)[32])tensor_9;
    float alpha = 1.0f;
    float beta = 1.0f;
    float (*C)[32] = (float (*)[32])tensor_linear_list_1_bias;
    for (uint32_t r = 0; r < M; r++)
        for (uint32_t c = 0; c < N; c++) {
            float ABrc = 0;
            for (uint32_t i = 0; i < K; i++) {
                float B = tensor_linear_list_1_weight[c][i];
                ABrc += A[r][i] * B;
            }
            float tmp = ABrc * alpha;
            tmp += C[0][c] * beta;
            Y[r][c] = tmp;
        }
}

static inline void node_Relu_3(const float tensor_9[1][32], float tensor_10[1][32]) {
    float *X = (float *)tensor_9;
    float *Y = (float *)tensor_10;
    for (uint32_t i = 0; i < 32; i++)
        Y[i] = X[i] > 0 ? X[i] : 0;
}

static inline void node_Gemm_4(const float tensor_10[1][32], const float tensor_linear_list_2_weight[3][32], const float tensor_linear_list_2_bias[3], float tensor_output[1][3]) {
    const int M = 1;
    const int K = 32;
    const int N = 3;
    float (*A)[32] = (float (*)[32])tensor_10;
    float (*Y)[3] = (float (*)[3])tensor_output;
    float alpha = 1.0f;
    float beta = 1.0f;
    float (*C)[3] = (float (*)[3])tensor_linear_list_2_bias;
    for (uint32_t r = 0; r < M; r++)
        for (uint32_t c = 0; c < N; c++) {
            float ABrc = 0;
            for (uint32_t i = 0; i < K; i++) {
                float B = tensor_linear_list_2_weight[c][i];
                ABrc += A[r][i] * B;
            }
            float tmp = ABrc * alpha;
            tmp += C[0][c] * beta;
            Y[r][c] = tmp;
        }
}

void entry(const float tensor_input[1][3], float tensor_output[1][3]) {
    node_Gemm_0(tensor_input, tensor_linear_list_0_weight, tensor_linear_list_0_bias, tu0.tensor_7);
    node_Relu_1(tu0.tensor_7, tu1.tensor_8);
    node_Gemm_2(tu1.tensor_8, tensor_linear_list_1_weight, tensor_linear_list_1_bias, tu0.tensor_9);
    node_Relu_3(tu0.tensor_9, tu1.tensor_10);
    node_Gemm_4(tu1.tensor_10, tensor_linear_list_2_weight, tensor_linear_list_2_bias, tensor_output);
}