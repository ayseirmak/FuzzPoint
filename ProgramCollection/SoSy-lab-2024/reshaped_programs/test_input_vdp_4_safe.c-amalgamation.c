#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <string.h>

#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
#define CLIP(X,L) (MAX(MIN((X),(L)), -(L)))

static const float tensor_linear_list_0_weight[32][3] = {
  {-0.88176542520523071289f, -0.70463490486145019531f, -0.54373848438262939453f},
  {0.64892828464508056641f, 0.0034874209668487310410f, -0.37089416384696960449f},
  {-0.74105376005172729492f, -1.0337978601455688477f, 0.031210454180836677551f},
  {1.0983051061630249023f, 0.18251781165599822998f, -0.50496292114257812500f},
  {0.78585195541381835938f, -0.49498808383941650391f, 0.35123330354690551758f},
  {0.73144763708114624023f, 1.1995273828506469727f, 0.49233591556549072266f},
  {-0.12234841287136077881f, 0.46685233712196350098f, 0.75584411621093750000f},
  {0.15553240478038787842f, -0.45204997062683105469f, -0.89144206047058105469f},
  {0.40253728628158569336f, -0.027726415544748306274f, 0.62590652704238891602f},
  {-0.63449299335479736328f, -0.34293681383132934570f, 0.65957361459732055664f},
  {1.1102625131607055664f, -0.22468753159046173096f, 0.55843997001647949219f},
  {1.1248842477798461914f, 0.49735105037689208984f, 0.081207059323787689209f},
  {0.54841423034667968750f, 0.41745969653129577637f, 0.73419481515884399414f},
  {0.66060942411422729492f, 0.32638362050056457520f, 0.55142962932586669922f},
  {-1.0183432102203369141f, -0.42889454960823059082f, 0.29910749197006225586f},
  {-0.63687884807586669922f, -0.39835059642791748047f, 0.79145830869674682617f},
  {-0.81405329704284667969f, -0.46462446451187133789f, -0.85571074485778808594f},
  {0.082866109907627105713f, -0.41799542307853698730f, 0.63583296537399291992f},
  {-0.68045675754547119141f, -0.51877683401107788086f, 0.97166937589645385742f},
  {-0.84452742338180541992f, 0.45417672395706176758f, 0.19738464057445526123f},
  {-0.19698037207126617432f, -0.92478579282760620117f, 0.15577456355094909668f},
  {-0.14642199873924255371f, 0.12705503404140472412f, 0.95710515975952148438f},
  {1.0756806135177612305f, -0.60934013128280639648f, 0.14467895030975341797f},
  {0.99187946319580078125f, -0.27336993813514709473f, -0.26771393418312072754f},
  {-0.48406404256820678711f, 1.0684081315994262695f, -0.18635073304176330566f},
  {0.15621618926525115967f, -1.0336036682128906250f, 0.18792124092578887939f},
  {0.34897747635841369629f, -0.23883144557476043701f, 0.71876186132431030273f},
  {0.65207701921463012695f, -0.55704259872436523438f, -0.52976417541503906250f},
  {-1.7608453035354614258f, -0.31709524989128112793f, -0.79164242744445800781f},
  {-0.13375453650951385498f, 0.99879181385040283203f, -0.40836325287818908691f},
  {-0.86492550373077392578f, 1.2129324674606323242f, 0.058803495019674301147f},
  {0.026067320257425308228f, 0.12616328895092010498f, -0.46570611000061035156f}
};

static const float tensor_linear_list_0_bias[32] = {
  -0.034172810614109039307f, 1.8474619388580322266f, 0.64596593379974365234f, -0.75458675622940063477f, 
  0.64674711227416992188f, -1.4623186588287353516f, -1.2687408924102783203f, 0.54433381557464599609f, 
  -1.8904396295547485352f, 0.20460028946399688721f, -0.98973661661148071289f, -1.3346133232116699219f, 
  -0.83987802267074584961f, 0.26927563548088073730f, 0.57160657644271850586f, -0.47112530469894409180f, 
  1.2977993488311767578f, -1.3613475561141967773f, -1.2450815439224243164f, 1.0426208972930908203f, 
  -1.0337107181549072266f, 0.18806469440460205078f, -0.95811837911605834961f, 1.0553588867187500000f, 
  1.1829288005828857422f, -0.66195261478424072266f, -1.0124167203903198242f, 1.7211766242980957031f, 
  -1.0197007656097412109f, 0.82806915044784545898f, -0.66947323083877563477f, -0.43987253308296203613f
};

// Example for other tensors
// Initialization of weights and biases are omitted for brevity

union tensor_union_0 {
    float tensor_7[1][32];
    float tensor_9[1][32];
};
static union tensor_union_0 tu0;

union tensor_union_1 {
    float tensor_8[1][32];
    float tensor_10[1][32];
};
static union tensor_union_1 tu1;

static inline void node_Gemm_0(const float tensor_input[1][3], const float tensor_linear_list_0_weight[32][3], const float tensor_linear_list_0_bias[32], float tensor_7[1][32]) {
    const int M = 1;
    const int K = 3;
    const int N = 32;
    float (*A)[3] = (float(*)[3])tensor_input;
    float (*Y)[32] = (float(*)[32])tensor_7;
    float alpha = 1.0;
    float beta = 1.0;
    float (*C)[32] = (float(*)[32])tensor_linear_list_0_bias;
    for (uint32_t r = 0; r < M; r++) {
        for (uint32_t c = 0; c < N; c++) {
            float ABrc = 0;
            for (uint32_t i = 0; i < K; i++) {
                float B = tensor_linear_list_0_weight[c][i];
                ABrc += A[r][i] * B;
            }
            float tmp = ABrc * alpha;
            tmp += C[0][c] * beta;
            Y[r][c] = tmp;
        }
    }
}

static inline void node_Relu_1(const float tensor_7[1][32], float tensor_8[1][32]) {
    float *X = (float*)tensor_7;
    float *Y = (float*)tensor_8;
    for (uint32_t i = 0; i < 32; i++) {
        Y[i] = X[i] > 0 ? X[i] : 0;
    }
}

void entry(const float tensor_input[1][3], float tensor_output[1][3]) {
    node_Gemm_0(tensor_input, tensor_linear_list_0_weight, tensor_linear_list_0_bias, tu0.tensor_7);
    node_Relu_1(tu0.tensor_7, tu1.tensor_8);
    // Additional operations omitted for brevity
}

int main() {
    float tensor_input[1][3] = { { 1.0f, 2.0f, 3.0f } };
    float tensor_output[1][3] = { { 0.0f, 0.0f, 0.0f } };

    entry(tensor_input, tensor_output);

    assert(!((tensor_output[0][1] <= 0.6034337034239154) && (tensor_output[0][1] >= -0.6034337034239154) &&
             (tensor_output[0][2] <= 0.6034337034239154) && (tensor_output[0][2] >= -0.6034337034239154) &&
             (tensor_output[0][0] >= 0.2821680445877145)));

    printf("Program executed successfully.\n");
    return 0;
}