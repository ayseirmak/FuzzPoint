#include <stdio.h>
#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))

void entry(const float tensor_input[1][4], float tensor_output[1][2]);

static const float tensor_q_net_0_weight[64][4] = {
    {0.15721032023429870605f, 0.11475459486246109009f, -0.63993811607360839844f, -0.069510847330093383789f},
    {0.17542746663093566895f, 0.037346746772527694702f, 0.11804900318384170532f, -0.42608326673507690430f},
    //... Complete weight matrix
};

static const float tensor_q_net_0_bias[64] = {
    -0.038480948656797409058f, 0.12814424932003021240f, 0.49260348081588745117f, -0.30465084314346313477f,
    //... Complete bias array
};

static const float tensor_q_net_2_weight[64][64] = {
    {-0.081372834742069244385f, 0.024248756468296051025f, 0.085219748318195343018f, -0.020931074395775794983f,
     0.092145785689353942871f, 0.051900878548622131348f, -0.091962411999702453613f, 0.012122990563511848450f,
     -0.096147723495960235596f, 0.11863323301076889038f, -0.034693796187639236450f, -0.066232405602931976318f,
     -0.15095156431198120117f, -0.17523497343063354492f, 0.11800386011600494385f, 0.016400158405303955078f,
     0.077730171382427215576f, 0.085327595472335815430f, 0.098276004195213317871f, 0.22289833426475524902f,
     0.018943466246128082275f, 0.088348664343357086182f, 0.0055694859474897384644f, 0.020647743716835975647f,
     0.083886988461017608643f, -0.12078075855970382690f, -0.097537018358707427979f, 0.055285315960645675659f,
     -0.015381305478513240814f, 0.12187845259904861450f, -0.19759547710418701172f, 0.024525033310055732727f,
     0.028528936207294464111f, -0.070564292371273040771f, 0.051963280886411666870f, 0.090760760009288787842f,
     -0.12127671390771865845f, -0.059935815632343292236f, -0.077119290828704833984f, -0.078511618077754974365f,
     0.018362935632467269897f, -0.081992305815219879150f, 0.18881429731845855713f, -0.041745025664567947388f,
     -0.10426150262355804443f, 0.012190807610750198364f, 0.036430440843105316162f, -0.019101515412330627441f,
     0.083770230412483215332f, 0.17562228441238403320f, 0.33865499496459960938f, 0.12329152226448059082f,
     -0.061573341488838195801f, -0.018120002001523971558f, 0.035032179206609725952f, 0.20414918661117553711f,
     0.13209012150764465332f, 0.10642226785421371460f, 0.099781796336174011230f, 0.085235834121704101562f,
     0.0046696858480572700500f, -0.073618113994598388672f, 0.18081563711166381836f, -0.053694937378168106079f},
    //... Complete weight matrix
};

static const float tensor_q_net_2_bias[64] = {
    0.0096521666273474693298f, 0.033651806414127349854f, 0.039734158664941787720f, 0.20449157059192657471f,
    //... Complete bias array
};

static const float tensor_q_net_4_weight[2][64] = {
    {-0.10003891587257385254f, -0.22389468550682067871f, -0.24801196157932281494f, 0.11498097330331802368f,
     0.28772687911987304688f, -0.16866405308246612549f, 0.20909047126770019531f, -0.21250520646572113037f,
     -0.22376564145088195801f, 0.21262970566749572754f, -0.10199058055877685547f, -0.22679378092288970947f,
     0.11511342227458953857f, 0.15330210328102111816f, -0.10844686627388000488f, 0.17825371026992797852f,
     0.059347081929445266724f, 0.21142321825027465820f, -0.16515047848224639893f, -0.17857280373573303223f,
     0.22156931459903717041f, 0.18464004993438720703f, -0.26450186967849731445f, 0.11040878295898437500f,
     -0.091056838631629943848f, 0.0013872138224542140961f, 0.18776123225688934326f, 0.18121501803398132324f,
     0.11458509415388107300f, -0.11783507466316223145f, -0.12730509042739868164f, 0.18567420542240142822f,
     0.032896466553211212158f, 0.10013416409492492676f, -0.081150569021701812744f, -0.11053027212619781494f,
     0.22552049160003662109f, -0.0011648660292848944664f, -0.038057755678892135620f, -0.056109391152858734131f,
     0.19609737396240234375f, 0.091320544481277465820f, 0.20271755754947662354f, -0.16160650551319122314f,
     0.19359958171844482422f, -0.11616066098213195801f, 0.021920168772339820862f, 0.24542203545570373535f,
     -0.14282654225826263428f, 0.13642586767673492432f, -0.20393803715705871582f, 0.20961524546146392822f,
     -0.11975769698619842529f, 0.11171920597553253174f, 0.11423823237419128418f, -0.13448771834373474121f,
     0.23380319774150848389f, 0.13872042298316955566f, -0.16640475392341613770f, 0.0080497665330767631531f,
     0.058250959962606430054f, 0.10097389668226242065f, -0.23964695632457733154f, 0.031074119731783866882f},
    //... Complete weight matrix
};

static const float tensor_q_net_4_bias[2] = {
    0.020197313278913497925f, 0.00082921260036528110504f
};

void node_Flatten_0(const float tensor_input[1][4], float tensor_7[1][4]) {
    for (uint32_t i = 0; i < 4; i++)
        tensor_7[0][i] = tensor_input[0][i];
}

void node_Gemm_1(const float tensor_7[1][4], float tensor_8[1][64]) {
    for (uint32_t i = 0; i < 64; i++) {
        tensor_8[0][i] = tensor_q_net_0_bias[i];
        for (uint32_t j = 0; j < 4; j++)
            tensor_8[0][i] += tensor_q_net_0_weight[i][j] * tensor_7[0][j];
    }
}

void node_Relu_2(float tensor_9[1][64], const float tensor_8[1][64]) {
    for (uint32_t i = 0; i < 64; i++) 
        tensor_9[0][i] = fmaxf(0, tensor_8[0][i]);
}

void node_Gemm_3(const float tensor_9[1][64], float tensor_10[1][64]) {
    for (uint32_t i = 0; i < 64; i++) {
        tensor_10[0][i] = tensor_q_net_2_bias[i];
        for (uint32_t j = 0; j < 64; j++)
            tensor_10[0][i] += tensor_q_net_2_weight[i][j] * tensor_9[0][j];
    }
}

void node_Relu_4(float tensor_11[1][64], const float tensor_10[1][64]) {
    for (uint32_t i = 0; i < 64; i++)
        tensor_11[0][i] = fmaxf(0, tensor_10[0][i]);
}

void node_Gemm_5(float tensor_output[1][2], const float tensor_11[1][64]) {
    for (uint32_t i = 0; i < 2; i++) {
        tensor_output[0][i] = tensor_q_net_4_bias[i];
        for (uint32_t j = 0; j < 64; j++)
            tensor_output[0][i] += tensor_q_net_4_weight[i][j] * tensor_11[0][j];
    }
}

void entry(const float tensor_input[1][4], float tensor_output[1][2]) {
    float tensor_7[1][4];
    float tensor_8[1][64];
    float tensor_9[1][64];
    float tensor_10[1][64];
    float tensor_11[1][64];

    node_Flatten_0(tensor_input, tensor_7);
    node_Gemm_1(tensor_7, tensor_8);
    node_Relu_2(tensor_9, tensor_8);
    node_Gemm_3(tensor_9, tensor_10);
    node_Relu_4(tensor_11, tensor_10);
    node_Gemm_5(tensor_output, tensor_11);
}

int main() {
    float tensor_input[1][4] = {
        {0.45f, -0.3f, 0.05f, 0.33f}
    };
    float tensor_output[1][2];

    entry(tensor_input, tensor_output);

    printf("Tensor Output[0][0]: %f\n", tensor_output[0][0]);
    printf("Tensor Output[0][1]: %f\n", tensor_output[0][1]);

    return 0;
}